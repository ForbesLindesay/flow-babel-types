// @flow
// generated by src/generate-code.js

type Location = {
  start: {line: number, column: number},
  end: {line: number, column: number},
};

declare class AnyTypeAnnotationNode {
  type: 'AnyTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class ArrayExpressionNode {
  type: 'ArrayExpression',
  loc: ?Location,
  elements: $ReadOnlyArray<ArrayExpressionElementsNode | null>,

  // alias: Expression
  // alias: Babel
}

declare class ArrayPatternNode {
  type: 'ArrayPattern',
  loc: ?Location,
  elements: $ReadOnlyArray<ArrayPatternElementsNode>,
  typeAnnotation: mixed,
  decorators: ?$ReadOnlyArray<DecoratorNode>,

  // alias: Pattern
  // alias: LVal
  // alias: Babel
}

declare class ArrayTypeAnnotationNode {
  type: 'ArrayTypeAnnotation',
  loc: ?Location,
  elementType: mixed,

  // alias: Flow
  // alias: Babel
}

declare class ArrowFunctionExpressionNode {
  type: 'ArrowFunctionExpression',
  loc: ?Location,
  params: $ReadOnlyArray<LValNode>,
  body: ArrowFunctionExpressionBodyNode,
  async: boolean,
  returnType: ?mixed,
  typeParameters: ?mixed,

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: Babel
}

declare class AssignmentExpressionNode {
  type: 'AssignmentExpression',
  loc: ?Location,
  operator: string,
  left: LValNode,
  right: ExpressionNode,

  // alias: Expression
  // alias: Babel
}

declare class AssignmentPatternNode {
  type: 'AssignmentPattern',
  loc: ?Location,
  left: IdentifierNode,
  right: ExpressionNode,
  decorators: ?$ReadOnlyArray<DecoratorNode>,

  // alias: Pattern
  // alias: LVal
  // alias: Babel
}

declare class AwaitExpressionNode {
  type: 'AwaitExpression',
  loc: ?Location,
  argument: ExpressionNode,

  // alias: Expression
  // alias: Terminatorless
  // alias: Babel
}

declare class BinaryExpressionNode {
  type: 'BinaryExpression',
  loc: ?Location,
  operator:
    | '+'
    | '-'
    | '/'
    | '%'
    | '*'
    | '**'
    | '&'
    | '|'
    | '>>'
    | '>>>'
    | '<<'
    | '^'
    | '=='
    | '==='
    | '!='
    | '!=='
    | 'in'
    | 'instanceof'
    | '>'
    | '<'
    | '>='
    | '<=',
  left: ExpressionNode,
  right: ExpressionNode,

  // alias: Binary
  // alias: Expression
  // alias: Babel
}

declare class BindExpressionNode {
  type: 'BindExpression',
  loc: ?Location,
  object: mixed,
  callee: mixed,

  // alias: Expression
  // alias: Babel
}

declare class BlockStatementNode {
  type: 'BlockStatement',
  loc: ?Location,
  body: $ReadOnlyArray<StatementNode>,
  directives: $ReadOnlyArray<DirectiveNode>,

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: Statement
  // alias: ArrowFunctionExpressionBody
  // alias: Babel
}

declare class BooleanLiteralNode {
  type: 'BooleanLiteral',
  loc: ?Location,
  value: boolean,

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: Babel
}

declare class BooleanLiteralTypeAnnotationNode {
  type: 'BooleanLiteralTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: Babel
}

declare class BooleanTypeAnnotationNode {
  type: 'BooleanTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class BreakStatementNode {
  type: 'BreakStatement',
  loc: ?Location,
  label: ?IdentifierNode,

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: Babel
}

declare class CallExpressionNode {
  type: 'CallExpression',
  loc: ?Location,
  callee: ExpressionNode,
  arguments: $ReadOnlyArray<ArrayExpressionElementsNode>,

  // alias: Expression
  // alias: Babel
}

declare class CatchClauseNode {
  type: 'CatchClause',
  loc: ?Location,
  param: IdentifierNode,
  body: BlockStatementNode,

  // alias: Scopable
  // alias: Babel
}

declare class ClassBodyNode {
  type: 'ClassBody',
  loc: ?Location,
  body: $ReadOnlyArray<ClassBodyBodyNode>,

  // alias: Babel
}

declare class ClassDeclarationNode {
  type: 'ClassDeclaration',
  loc: ?Location,
  id: IdentifierNode,
  superClass: ?ExpressionNode,
  body: ClassBodyNode,
  decorators: $ReadOnlyArray<DecoratorNode>,
  implements: ?mixed,
  mixins: ?mixed,
  superTypeParameters: ?mixed,
  typeParameters: ?mixed,

  // alias: Scopable
  // alias: Class
  // alias: Statement
  // alias: Declaration
  // alias: Pureish
  // alias: Babel
}

declare class ClassExpressionNode {
  type: 'ClassExpression',
  loc: ?Location,
  id: ?IdentifierNode,
  superClass: ?ExpressionNode,
  body: ClassBodyNode,
  decorators: $ReadOnlyArray<DecoratorNode>,
  implements: ?mixed,
  mixins: ?mixed,
  superTypeParameters: ?mixed,
  typeParameters: ?mixed,

  // alias: Scopable
  // alias: Class
  // alias: Expression
  // alias: Pureish
  // alias: Babel
}

declare class ClassImplementsNode {
  type: 'ClassImplements',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,

  // alias: Flow
  // alias: Babel
}

declare class ClassMethodNode {
  type: 'ClassMethod',
  loc: ?Location,
  kind: 'get' | 'set' | 'method' | 'constructor',
  key: ExpressionNode,
  params: $ReadOnlyArray<LValNode>,
  body: BlockStatementNode,
  computed: boolean,
  async: ?boolean,
  decorators: ?mixed,
  generator: ?boolean,
  returnType: ?mixed,
  typeParameters: ?mixed,

  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: ClassBodyBody
  // alias: Babel
}

declare class ClassPropertyNode {
  type: 'ClassProperty',
  loc: ?Location,
  key: mixed,
  value: mixed,
  typeAnnotation: mixed,
  decorators: mixed,
  computed: boolean,

  // alias: Property
  // alias: ClassBodyBody
  // alias: Babel
}

declare class ConditionalExpressionNode {
  type: 'ConditionalExpression',
  loc: ?Location,
  test: ExpressionNode,
  consequent: ExpressionNode,
  alternate: ExpressionNode,

  // alias: Expression
  // alias: Conditional
  // alias: Babel
}

declare class ContinueStatementNode {
  type: 'ContinueStatement',
  loc: ?Location,
  label: ?IdentifierNode,

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: Babel
}

declare class DebuggerStatementNode {
  type: 'DebuggerStatement',
  loc: ?Location,

  // alias: Statement
  // alias: Babel
}

declare class DeclareClassNode {
  type: 'DeclareClass',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,
  extends: mixed,
  body: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareFunctionNode {
  type: 'DeclareFunction',
  loc: ?Location,
  id: IdentifierNode,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareInterfaceNode {
  type: 'DeclareInterface',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,
  extends: mixed,
  body: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareModuleNode {
  type: 'DeclareModule',
  loc: ?Location,
  id: IdentifierNode,
  body: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareModuleExportsNode {
  type: 'DeclareModuleExports',
  loc: ?Location,
  typeAnnotation: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareTypeAliasNode {
  type: 'DeclareTypeAlias',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,
  right: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DeclareVariableNode {
  type: 'DeclareVariable',
  loc: ?Location,
  id: IdentifierNode,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class DecoratorNode {
  type: 'Decorator',
  loc: ?Location,
  expression: ExpressionNode,

  // alias: Babel
}

declare class DirectiveNode {
  type: 'Directive',
  loc: ?Location,
  value: DirectiveLiteralNode,

  // alias: Babel
}

declare class DirectiveLiteralNode {
  type: 'DirectiveLiteral',
  loc: ?Location,
  value: string,

  // alias: Babel
}

declare class DoExpressionNode {
  type: 'DoExpression',
  loc: ?Location,
  body: BlockStatementNode,

  // alias: Expression
  // alias: Babel
}

declare class DoWhileStatementNode {
  type: 'DoWhileStatement',
  loc: ?Location,
  test: ExpressionNode,
  body: StatementNode,

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: Babel
}

declare class EmptyStatementNode {
  type: 'EmptyStatement',
  loc: ?Location,

  // alias: Statement
  // alias: Babel
}

declare class EmptyTypeAnnotationNode {
  type: 'EmptyTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class ExistentialTypeParamNode {
  type: 'ExistentialTypeParam',
  loc: ?Location,

  // alias: Flow
  // alias: Babel
}

declare class ExportAllDeclarationNode {
  type: 'ExportAllDeclaration',
  loc: ?Location,
  source: StringLiteralNode,

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: Babel
}

declare class ExportDefaultDeclarationNode {
  type: 'ExportDefaultDeclaration',
  loc: ?Location,
  declaration: ExportDefaultDeclarationDeclarationNode,

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: Babel
}

declare class ExportDefaultSpecifierNode {
  type: 'ExportDefaultSpecifier',
  loc: ?Location,
  exported: IdentifierNode,

  // alias: ModuleSpecifier
  // alias: Babel
}

declare class ExportNamedDeclarationNode {
  type: 'ExportNamedDeclaration',
  loc: ?Location,
  declaration: ?DeclarationNode,
  specifiers: $ReadOnlyArray<ExportSpecifierNode>,
  source: ?StringLiteralNode,

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: Babel
}

declare class ExportNamespaceSpecifierNode {
  type: 'ExportNamespaceSpecifier',
  loc: ?Location,
  exported: IdentifierNode,

  // alias: ModuleSpecifier
  // alias: Babel
}

declare class ExportSpecifierNode {
  type: 'ExportSpecifier',
  loc: ?Location,
  local: IdentifierNode,
  exported: IdentifierNode,

  // alias: ModuleSpecifier
  // alias: Babel
}

declare class ExpressionStatementNode {
  type: 'ExpressionStatement',
  loc: ?Location,
  expression: ExpressionNode,

  // alias: Statement
  // alias: ExpressionWrapper
  // alias: Babel
}

declare class FileNode {
  type: 'File',
  loc: ?Location,
  program: ProgramNode,
  comments: mixed,
  tokens: mixed,

  // alias: Babel
}

declare class ForAwaitStatementNode {
  type: 'ForAwaitStatement',
  loc: ?Location,
  left: ForAwaitStatementLeftNode,
  right: ExpressionNode,
  body: StatementNode,

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: Babel
}

declare class ForInStatementNode {
  type: 'ForInStatement',
  loc: ?Location,
  left: ForAwaitStatementLeftNode,
  right: ExpressionNode,
  body: StatementNode,

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: Babel
}

declare class ForOfStatementNode {
  type: 'ForOfStatement',
  loc: ?Location,
  left: ForAwaitStatementLeftNode,
  right: ExpressionNode,
  body: StatementNode,

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: Babel
}

declare class ForStatementNode {
  type: 'ForStatement',
  loc: ?Location,
  init: ?ForStatementInitNode,
  test: ?ExpressionNode,
  update: ?ExpressionNode,
  body: StatementNode,

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: Babel
}

declare class FunctionDeclarationNode {
  type: 'FunctionDeclaration',
  loc: ?Location,
  id: IdentifierNode,
  params: $ReadOnlyArray<LValNode>,
  body: BlockStatementNode,
  generator: boolean,
  async: boolean,
  returnType: ?mixed,
  typeParameters: ?mixed,

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Statement
  // alias: Pureish
  // alias: Declaration
  // alias: ExportDefaultDeclarationDeclaration
  // alias: Babel
}

declare class FunctionExpressionNode {
  type: 'FunctionExpression',
  loc: ?Location,
  id: ?IdentifierNode,
  params: $ReadOnlyArray<LValNode>,
  body: BlockStatementNode,
  generator: boolean,
  async: boolean,
  returnType: ?mixed,
  typeParameters: ?mixed,

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: Babel
}

declare class FunctionTypeAnnotationNode {
  type: 'FunctionTypeAnnotation',
  loc: ?Location,
  typeParameters: mixed,
  params: mixed,
  rest: mixed,
  returnType: mixed,

  // alias: Flow
  // alias: Babel
}

declare class FunctionTypeParamNode {
  type: 'FunctionTypeParam',
  loc: ?Location,
  name: mixed,
  typeAnnotation: mixed,

  // alias: Flow
  // alias: Babel
}

declare class GenericTypeAnnotationNode {
  type: 'GenericTypeAnnotation',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,

  // alias: Flow
  // alias: Babel
}

declare class IdentifierNode {
  type: 'Identifier',
  loc: ?Location,
  name: string,
  decorators: ?$ReadOnlyArray<DecoratorNode>,
  typeAnnotation: ?mixed,

  // alias: Expression
  // alias: LVal
  // alias: ArrayPatternElements
  // alias: Babel
}

declare class IfStatementNode {
  type: 'IfStatement',
  loc: ?Location,
  test: ExpressionNode,
  consequent: StatementNode,
  alternate: ?StatementNode,

  // alias: Statement
  // alias: Conditional
  // alias: Babel
}

declare class ImportNode {
  type: 'Import',
  loc: ?Location,

  // alias: Expression
  // alias: Babel
}

declare class ImportDeclarationNode {
  type: 'ImportDeclaration',
  loc: ?Location,
  specifiers: $ReadOnlyArray<ImportDeclarationSpecifiersNode>,
  source: StringLiteralNode,

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: Babel
}

declare class ImportDefaultSpecifierNode {
  type: 'ImportDefaultSpecifier',
  loc: ?Location,
  local: IdentifierNode,

  // alias: ModuleSpecifier
  // alias: ImportDeclarationSpecifiers
  // alias: Babel
}

declare class ImportNamespaceSpecifierNode {
  type: 'ImportNamespaceSpecifier',
  loc: ?Location,
  local: IdentifierNode,

  // alias: ModuleSpecifier
  // alias: ImportDeclarationSpecifiers
  // alias: Babel
}

declare class ImportSpecifierNode {
  type: 'ImportSpecifier',
  loc: ?Location,
  local: IdentifierNode,
  imported: IdentifierNode,
  importKind: ?null | 'type' | 'typeof',

  // alias: ModuleSpecifier
  // alias: ImportDeclarationSpecifiers
  // alias: Babel
}

declare class InterfaceDeclarationNode {
  type: 'InterfaceDeclaration',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,
  extends: mixed,
  body: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class InterfaceExtendsNode {
  type: 'InterfaceExtends',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,

  // alias: Flow
  // alias: Babel
}

declare class IntersectionTypeAnnotationNode {
  type: 'IntersectionTypeAnnotation',
  loc: ?Location,
  types: mixed,

  // alias: Flow
  // alias: Babel
}

declare class JSXAttributeNode {
  type: 'JSXAttribute',
  loc: ?Location,
  name: JSXAttributeNameNode,
  value: ?JSXAttributeValueNode,

  // alias: JSX
  // alias: Immutable
  // alias: Babel
}

declare class JSXClosingElementNode {
  type: 'JSXClosingElement',
  loc: ?Location,
  name: JSXClosingElementNameNode,

  // alias: JSX
  // alias: Immutable
  // alias: Babel
}

declare class JSXElementNode {
  type: 'JSXElement',
  loc: ?Location,
  openingElement: JSXOpeningElementNode,
  closingElement: ?JSXClosingElementNode,
  children: $ReadOnlyArray<JSXElementChildrenNode>,
  selfClosing: mixed,

  // alias: JSX
  // alias: Immutable
  // alias: Expression
  // alias: JSXAttributeValue
  // alias: JSXElementChildren
  // alias: Babel
}

declare class JSXEmptyExpressionNode {
  type: 'JSXEmptyExpression',
  loc: ?Location,

  // alias: JSX
  // alias: Expression
  // alias: Babel
}

declare class JSXExpressionContainerNode {
  type: 'JSXExpressionContainer',
  loc: ?Location,
  expression: ExpressionNode,

  // alias: JSX
  // alias: Immutable
  // alias: JSXAttributeValue
  // alias: JSXElementChildren
  // alias: Babel
}

declare class JSXIdentifierNode {
  type: 'JSXIdentifier',
  loc: ?Location,
  name: string,

  // alias: JSX
  // alias: Expression
  // alias: JSXAttributeName
  // alias: JSXClosingElementName
  // alias: Babel
}

declare class JSXMemberExpressionNode {
  type: 'JSXMemberExpression',
  loc: ?Location,
  object: JSXClosingElementNameNode,
  property: JSXIdentifierNode,

  // alias: JSX
  // alias: Expression
  // alias: JSXClosingElementName
  // alias: Babel
}

declare class JSXNamespacedNameNode {
  type: 'JSXNamespacedName',
  loc: ?Location,
  namespace: JSXIdentifierNode,
  name: JSXIdentifierNode,

  // alias: JSX
  // alias: JSXAttributeName
  // alias: Babel
}

declare class JSXOpeningElementNode {
  type: 'JSXOpeningElement',
  loc: ?Location,
  name: JSXClosingElementNameNode,
  attributes: $ReadOnlyArray<JSXOpeningElementAttributesNode>,
  selfClosing: boolean,

  // alias: JSX
  // alias: Immutable
  // alias: Babel
}

declare class JSXSpreadAttributeNode {
  type: 'JSXSpreadAttribute',
  loc: ?Location,
  argument: ExpressionNode,

  // alias: JSX
  // alias: JSXOpeningElementAttributes
  // alias: Babel
}

declare class JSXSpreadChildNode {
  type: 'JSXSpreadChild',
  loc: ?Location,
  expression: ExpressionNode,

  // alias: JSX
  // alias: Immutable
  // alias: JSXElementChildren
  // alias: Babel
}

declare class JSXTextNode {
  type: 'JSXText',
  loc: ?Location,
  value: string,

  // alias: JSX
  // alias: Immutable
  // alias: JSXElementChildren
  // alias: Babel
}

declare class LabeledStatementNode {
  type: 'LabeledStatement',
  loc: ?Location,
  label: IdentifierNode,
  body: StatementNode,

  // alias: Statement
  // alias: Babel
}

declare class LogicalExpressionNode {
  type: 'LogicalExpression',
  loc: ?Location,
  operator: '||' | '&&',
  left: ExpressionNode,
  right: ExpressionNode,

  // alias: Binary
  // alias: Expression
  // alias: Babel
}

declare class MemberExpressionNode {
  type: 'MemberExpression',
  loc: ?Location,
  object: ExpressionNode,
  property: ExpressionNode,
  computed: boolean,

  // alias: Expression
  // alias: LVal
  // alias: Babel
}

declare class MetaPropertyNode {
  type: 'MetaProperty',
  loc: ?Location,
  meta: string,
  property: string,

  // alias: Expression
  // alias: Babel
}

declare class MixedTypeAnnotationNode {
  type: 'MixedTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class NewExpressionNode {
  type: 'NewExpression',
  loc: ?Location,
  callee: ExpressionNode,
  arguments: $ReadOnlyArray<ArrayExpressionElementsNode>,

  // alias: Expression
  // alias: Babel
}

declare class NoopNode {
  type: 'Noop',
  loc: ?Location,

  // alias: Babel
}

declare class NullLiteralNode {
  type: 'NullLiteral',
  loc: ?Location,

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: Babel
}

declare class NullLiteralTypeAnnotationNode {
  type: 'NullLiteralTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class NullableTypeAnnotationNode {
  type: 'NullableTypeAnnotation',
  loc: ?Location,
  typeAnnotation: mixed,

  // alias: Flow
  // alias: Babel
}

declare class NumberTypeAnnotationNode {
  type: 'NumberTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class NumericLiteralNode {
  type: 'NumericLiteral',
  loc: ?Location,
  value: number,

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: Babel
}

declare class NumericLiteralTypeAnnotationNode {
  type: 'NumericLiteralTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: Babel
}

declare class ObjectExpressionNode {
  type: 'ObjectExpression',
  loc: ?Location,
  properties: $ReadOnlyArray<ObjectExpressionPropertiesNode>,

  // alias: Expression
  // alias: Babel
}

declare class ObjectMethodNode {
  type: 'ObjectMethod',
  loc: ?Location,
  kind: 'method' | 'get' | 'set',
  key: ExpressionNode,
  params: mixed,
  body: BlockStatementNode,
  computed: boolean,
  async: ?boolean,
  decorators: ?$ReadOnlyArray<DecoratorNode>,
  generator: ?boolean,
  returnType: ?mixed,
  typeParameters: ?mixed,

  // alias: UserWhitespacable
  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: ObjectMember
  // alias: ObjectExpressionProperties
  // alias: Babel
}

declare class ObjectPatternNode {
  type: 'ObjectPattern',
  loc: ?Location,
  properties: $ReadOnlyArray<ObjectPatternPropertiesNode>,
  typeAnnotation: mixed,
  decorators: ?$ReadOnlyArray<DecoratorNode>,

  // alias: Pattern
  // alias: LVal
  // alias: Babel
}

declare class ObjectPropertyNode {
  type: 'ObjectProperty',
  loc: ?Location,
  key: ExpressionNode,
  value: ObjectPropertyValueNode,
  computed: boolean,
  shorthand: boolean,
  decorators: ?$ReadOnlyArray<DecoratorNode>,

  // alias: UserWhitespacable
  // alias: Property
  // alias: ObjectMember
  // alias: ObjectExpressionProperties
  // alias: Babel
}

declare class ObjectTypeAnnotationNode {
  type: 'ObjectTypeAnnotation',
  loc: ?Location,
  properties: mixed,
  indexers: mixed,
  callProperties: mixed,

  // alias: Flow
  // alias: Babel
}

declare class ObjectTypeCallPropertyNode {
  type: 'ObjectTypeCallProperty',
  loc: ?Location,
  value: mixed,

  // alias: Flow
  // alias: UserWhitespacable
  // alias: Babel
}

declare class ObjectTypeIndexerNode {
  type: 'ObjectTypeIndexer',
  loc: ?Location,
  id: IdentifierNode,
  key: mixed,
  value: mixed,

  // alias: Flow
  // alias: UserWhitespacable
  // alias: Babel
}

declare class ObjectTypePropertyNode {
  type: 'ObjectTypeProperty',
  loc: ?Location,
  key: mixed,
  value: mixed,

  // alias: Flow
  // alias: UserWhitespacable
  // alias: Babel
}

declare class ObjectTypeSpreadPropertyNode {
  type: 'ObjectTypeSpreadProperty',
  loc: ?Location,
  argument: mixed,

  // alias: Flow
  // alias: UserWhitespacable
  // alias: Babel
}

declare class ParenthesizedExpressionNode {
  type: 'ParenthesizedExpression',
  loc: ?Location,
  expression: ExpressionNode,

  // alias: Expression
  // alias: ExpressionWrapper
  // alias: Babel
}

declare class ProgramNode {
  type: 'Program',
  loc: ?Location,
  body: $ReadOnlyArray<StatementNode>,
  directives: $ReadOnlyArray<DirectiveNode>,

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: FunctionParent
  // alias: Babel
}

declare class QualifiedTypeIdentifierNode {
  type: 'QualifiedTypeIdentifier',
  loc: ?Location,
  id: IdentifierNode,
  qualification: mixed,

  // alias: Flow
  // alias: Babel
}

declare class RegExpLiteralNode {
  type: 'RegExpLiteral',
  loc: ?Location,
  pattern: string,
  flags: string,

  // alias: Expression
  // alias: Literal
  // alias: Babel
}

declare class RestElementNode {
  type: 'RestElement',
  loc: ?Location,
  argument: LValNode,
  typeAnnotation: mixed,
  decorators: ?$ReadOnlyArray<DecoratorNode>,

  // alias: LVal
  // alias: ArrayPatternElements
  // alias: ObjectPropertyValue
  // alias: Babel
}

declare class RestPropertyNode {
  type: 'RestProperty',
  loc: ?Location,
  argument: LValNode,

  // alias: UnaryLike
  // alias: ObjectPatternProperties
  // alias: Babel
}

declare class ReturnStatementNode {
  type: 'ReturnStatement',
  loc: ?Location,
  argument: ?ExpressionNode,

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: Babel
}

declare class SequenceExpressionNode {
  type: 'SequenceExpression',
  loc: ?Location,
  expressions: $ReadOnlyArray<ExpressionNode>,

  // alias: Expression
  // alias: Babel
}

declare class SpreadElementNode {
  type: 'SpreadElement',
  loc: ?Location,
  argument: ExpressionNode,

  // alias: UnaryLike
  // alias: ArrayExpressionElements
  // alias: Babel
}

declare class SpreadPropertyNode {
  type: 'SpreadProperty',
  loc: ?Location,
  argument: ExpressionNode,

  // alias: UnaryLike
  // alias: ObjectExpressionProperties
  // alias: Babel
}

declare class StringLiteralNode {
  type: 'StringLiteral',
  loc: ?Location,
  value: string,

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: JSXAttributeValue
  // alias: Babel
}

declare class StringLiteralTypeAnnotationNode {
  type: 'StringLiteralTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: Babel
}

declare class StringTypeAnnotationNode {
  type: 'StringTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class SuperNode {
  type: 'Super',
  loc: ?Location,

  // alias: Expression
  // alias: Babel
}

declare class SwitchCaseNode {
  type: 'SwitchCase',
  loc: ?Location,
  test: ?ExpressionNode,
  consequent: $ReadOnlyArray<StatementNode>,

  // alias: Babel
}

declare class SwitchStatementNode {
  type: 'SwitchStatement',
  loc: ?Location,
  discriminant: ExpressionNode,
  cases: $ReadOnlyArray<SwitchCaseNode>,

  // alias: Statement
  // alias: BlockParent
  // alias: Scopable
  // alias: Babel
}

declare class TaggedTemplateExpressionNode {
  type: 'TaggedTemplateExpression',
  loc: ?Location,
  tag: ExpressionNode,
  quasi: TemplateLiteralNode,

  // alias: Expression
  // alias: Babel
}

declare class TemplateElementNode {
  type: 'TemplateElement',
  loc: ?Location,
  value: mixed,
  tail: boolean,

  // alias: Babel
}

declare class TemplateLiteralNode {
  type: 'TemplateLiteral',
  loc: ?Location,
  quasis: $ReadOnlyArray<TemplateElementNode>,
  expressions: $ReadOnlyArray<ExpressionNode>,

  // alias: Expression
  // alias: Literal
  // alias: Babel
}

declare class ThisExpressionNode {
  type: 'ThisExpression',
  loc: ?Location,

  // alias: Expression
  // alias: Babel
}

declare class ThisTypeAnnotationNode {
  type: 'ThisTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class ThrowStatementNode {
  type: 'ThrowStatement',
  loc: ?Location,
  argument: ExpressionNode,

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: Babel
}

declare class TryStatementNode {
  type: 'TryStatement',
  loc: ?Location,
  block: mixed,
  handler: ?mixed,
  finalizer: ?BlockStatementNode,
  body: ?BlockStatementNode,

  // alias: Statement
  // alias: Babel
}

declare class TupleTypeAnnotationNode {
  type: 'TupleTypeAnnotation',
  loc: ?Location,
  types: mixed,

  // alias: Flow
  // alias: Babel
}

declare class TypeAliasNode {
  type: 'TypeAlias',
  loc: ?Location,
  id: IdentifierNode,
  typeParameters: mixed,
  right: mixed,

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: Babel
}

declare class TypeAnnotationNode {
  type: 'TypeAnnotation',
  loc: ?Location,
  typeAnnotation: mixed,

  // alias: Flow
  // alias: Babel
}

declare class TypeCastExpressionNode {
  type: 'TypeCastExpression',
  loc: ?Location,
  expression: mixed,
  typeAnnotation: mixed,

  // alias: Flow
  // alias: ExpressionWrapper
  // alias: Expression
  // alias: Babel
}

declare class TypeParameterNode {
  type: 'TypeParameter',
  loc: ?Location,
  bound: mixed,

  // alias: Flow
  // alias: Babel
}

declare class TypeParameterDeclarationNode {
  type: 'TypeParameterDeclaration',
  loc: ?Location,
  params: mixed,

  // alias: Flow
  // alias: Babel
}

declare class TypeParameterInstantiationNode {
  type: 'TypeParameterInstantiation',
  loc: ?Location,
  params: mixed,

  // alias: Flow
  // alias: Babel
}

declare class TypeofTypeAnnotationNode {
  type: 'TypeofTypeAnnotation',
  loc: ?Location,
  argument: mixed,

  // alias: Flow
  // alias: Babel
}

declare class UnaryExpressionNode {
  type: 'UnaryExpression',
  loc: ?Location,
  operator: 'void' | 'delete' | '!' | '+' | '-' | '++' | '--' | '~' | 'typeof',
  argument: ExpressionNode,
  prefix: boolean,

  // alias: UnaryLike
  // alias: Expression
  // alias: Babel
}

declare class UnionTypeAnnotationNode {
  type: 'UnionTypeAnnotation',
  loc: ?Location,
  types: mixed,

  // alias: Flow
  // alias: Babel
}

declare class UpdateExpressionNode {
  type: 'UpdateExpression',
  loc: ?Location,
  operator: '++' | '--',
  argument: ExpressionNode,
  prefix: boolean,

  // alias: Expression
  // alias: Babel
}

declare class VariableDeclarationNode {
  type: 'VariableDeclaration',
  loc: ?Location,
  kind: 'var' | 'let' | 'const',
  declarations: $ReadOnlyArray<VariableDeclaratorNode>,

  // alias: Statement
  // alias: Declaration
  // alias: ForAwaitStatementLeft
  // alias: ForStatementInit
  // alias: Babel
}

declare class VariableDeclaratorNode {
  type: 'VariableDeclarator',
  loc: ?Location,
  id: LValNode,
  init: ?ExpressionNode,

  // alias: Babel
}

declare class VoidTypeAnnotationNode {
  type: 'VoidTypeAnnotation',
  loc: ?Location,

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: Babel
}

declare class WhileStatementNode {
  type: 'WhileStatement',
  loc: ?Location,
  test: ExpressionNode,
  body: WhileStatementBodyNode,

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: Babel
}

declare class WithStatementNode {
  type: 'WithStatement',
  loc: ?Location,
  object: mixed,
  body: WhileStatementBodyNode,

  // alias: Statement
  // alias: Babel
}

declare class YieldExpressionNode {
  type: 'YieldExpression',
  loc: ?Location,
  argument: ?ExpressionNode,
  delegate: boolean,

  // alias: Expression
  // alias: Terminatorless
  // alias: Babel
}

type FlowNode =
  | AnyTypeAnnotationNode
  | ArrayTypeAnnotationNode
  | BooleanLiteralTypeAnnotationNode
  | BooleanTypeAnnotationNode
  | ClassImplementsNode
  | DeclareClassNode
  | DeclareFunctionNode
  | DeclareInterfaceNode
  | DeclareModuleNode
  | DeclareModuleExportsNode
  | DeclareTypeAliasNode
  | DeclareVariableNode
  | EmptyTypeAnnotationNode
  | ExistentialTypeParamNode
  | FunctionTypeAnnotationNode
  | FunctionTypeParamNode
  | GenericTypeAnnotationNode
  | InterfaceDeclarationNode
  | InterfaceExtendsNode
  | IntersectionTypeAnnotationNode
  | MixedTypeAnnotationNode
  | NullLiteralTypeAnnotationNode
  | NullableTypeAnnotationNode
  | NumberTypeAnnotationNode
  | NumericLiteralTypeAnnotationNode
  | ObjectTypeAnnotationNode
  | ObjectTypeCallPropertyNode
  | ObjectTypeIndexerNode
  | ObjectTypePropertyNode
  | ObjectTypeSpreadPropertyNode
  | QualifiedTypeIdentifierNode
  | StringLiteralTypeAnnotationNode
  | StringTypeAnnotationNode
  | ThisTypeAnnotationNode
  | TupleTypeAnnotationNode
  | TypeAliasNode
  | TypeAnnotationNode
  | TypeCastExpressionNode
  | TypeParameterNode
  | TypeParameterDeclarationNode
  | TypeParameterInstantiationNode
  | TypeofTypeAnnotationNode
  | UnionTypeAnnotationNode
  | VoidTypeAnnotationNode;

type FlowBaseAnnotationNode =
  | AnyTypeAnnotationNode
  | BooleanTypeAnnotationNode
  | EmptyTypeAnnotationNode
  | MixedTypeAnnotationNode
  | NullLiteralTypeAnnotationNode
  | NumberTypeAnnotationNode
  | StringTypeAnnotationNode
  | ThisTypeAnnotationNode
  | VoidTypeAnnotationNode;

type BabelNode =
  | AnyTypeAnnotationNode
  | ArrayExpressionNode
  | ArrayPatternNode
  | ArrayTypeAnnotationNode
  | ArrowFunctionExpressionNode
  | AssignmentExpressionNode
  | AssignmentPatternNode
  | AwaitExpressionNode
  | BinaryExpressionNode
  | BindExpressionNode
  | BlockStatementNode
  | BooleanLiteralNode
  | BooleanLiteralTypeAnnotationNode
  | BooleanTypeAnnotationNode
  | BreakStatementNode
  | CallExpressionNode
  | CatchClauseNode
  | ClassBodyNode
  | ClassDeclarationNode
  | ClassExpressionNode
  | ClassImplementsNode
  | ClassMethodNode
  | ClassPropertyNode
  | ConditionalExpressionNode
  | ContinueStatementNode
  | DebuggerStatementNode
  | DeclareClassNode
  | DeclareFunctionNode
  | DeclareInterfaceNode
  | DeclareModuleNode
  | DeclareModuleExportsNode
  | DeclareTypeAliasNode
  | DeclareVariableNode
  | DecoratorNode
  | DirectiveNode
  | DirectiveLiteralNode
  | DoExpressionNode
  | DoWhileStatementNode
  | EmptyStatementNode
  | EmptyTypeAnnotationNode
  | ExistentialTypeParamNode
  | ExportAllDeclarationNode
  | ExportDefaultDeclarationNode
  | ExportDefaultSpecifierNode
  | ExportNamedDeclarationNode
  | ExportNamespaceSpecifierNode
  | ExportSpecifierNode
  | ExpressionStatementNode
  | FileNode
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | FunctionTypeAnnotationNode
  | FunctionTypeParamNode
  | GenericTypeAnnotationNode
  | IdentifierNode
  | IfStatementNode
  | ImportNode
  | ImportDeclarationNode
  | ImportDefaultSpecifierNode
  | ImportNamespaceSpecifierNode
  | ImportSpecifierNode
  | InterfaceDeclarationNode
  | InterfaceExtendsNode
  | IntersectionTypeAnnotationNode
  | JSXAttributeNode
  | JSXClosingElementNode
  | JSXElementNode
  | JSXEmptyExpressionNode
  | JSXExpressionContainerNode
  | JSXIdentifierNode
  | JSXMemberExpressionNode
  | JSXNamespacedNameNode
  | JSXOpeningElementNode
  | JSXSpreadAttributeNode
  | JSXSpreadChildNode
  | JSXTextNode
  | LabeledStatementNode
  | LogicalExpressionNode
  | MemberExpressionNode
  | MetaPropertyNode
  | MixedTypeAnnotationNode
  | NewExpressionNode
  | NoopNode
  | NullLiteralNode
  | NullLiteralTypeAnnotationNode
  | NullableTypeAnnotationNode
  | NumberTypeAnnotationNode
  | NumericLiteralNode
  | NumericLiteralTypeAnnotationNode
  | ObjectExpressionNode
  | ObjectMethodNode
  | ObjectPatternNode
  | ObjectPropertyNode
  | ObjectTypeAnnotationNode
  | ObjectTypeCallPropertyNode
  | ObjectTypeIndexerNode
  | ObjectTypePropertyNode
  | ObjectTypeSpreadPropertyNode
  | ParenthesizedExpressionNode
  | ProgramNode
  | QualifiedTypeIdentifierNode
  | RegExpLiteralNode
  | RestElementNode
  | RestPropertyNode
  | ReturnStatementNode
  | SequenceExpressionNode
  | SpreadElementNode
  | SpreadPropertyNode
  | StringLiteralNode
  | StringLiteralTypeAnnotationNode
  | StringTypeAnnotationNode
  | SuperNode
  | SwitchCaseNode
  | SwitchStatementNode
  | TaggedTemplateExpressionNode
  | TemplateElementNode
  | TemplateLiteralNode
  | ThisExpressionNode
  | ThisTypeAnnotationNode
  | ThrowStatementNode
  | TryStatementNode
  | TupleTypeAnnotationNode
  | TypeAliasNode
  | TypeAnnotationNode
  | TypeCastExpressionNode
  | TypeParameterNode
  | TypeParameterDeclarationNode
  | TypeParameterInstantiationNode
  | TypeofTypeAnnotationNode
  | UnaryExpressionNode
  | UnionTypeAnnotationNode
  | UpdateExpressionNode
  | VariableDeclarationNode
  | VariableDeclaratorNode
  | VoidTypeAnnotationNode
  | WhileStatementNode
  | WithStatementNode
  | YieldExpressionNode;

type ExpressionNode =
  | ArrayExpressionNode
  | ArrowFunctionExpressionNode
  | AssignmentExpressionNode
  | AwaitExpressionNode
  | BinaryExpressionNode
  | BindExpressionNode
  | BooleanLiteralNode
  | CallExpressionNode
  | ClassExpressionNode
  | ConditionalExpressionNode
  | DoExpressionNode
  | FunctionExpressionNode
  | IdentifierNode
  | ImportNode
  | JSXElementNode
  | JSXEmptyExpressionNode
  | JSXIdentifierNode
  | JSXMemberExpressionNode
  | LogicalExpressionNode
  | MemberExpressionNode
  | MetaPropertyNode
  | NewExpressionNode
  | NullLiteralNode
  | NumericLiteralNode
  | ObjectExpressionNode
  | ParenthesizedExpressionNode
  | RegExpLiteralNode
  | SequenceExpressionNode
  | StringLiteralNode
  | SuperNode
  | TaggedTemplateExpressionNode
  | TemplateLiteralNode
  | ThisExpressionNode
  | TypeCastExpressionNode
  | UnaryExpressionNode
  | UpdateExpressionNode
  | YieldExpressionNode;

type PatternNode = ArrayPatternNode | AssignmentPatternNode | ObjectPatternNode;

type LValNode =
  | ArrayPatternNode
  | AssignmentPatternNode
  | IdentifierNode
  | MemberExpressionNode
  | ObjectPatternNode
  | RestElementNode;

type ScopableNode =
  | ArrowFunctionExpressionNode
  | BlockStatementNode
  | CatchClauseNode
  | ClassDeclarationNode
  | ClassExpressionNode
  | ClassMethodNode
  | DoWhileStatementNode
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | ObjectMethodNode
  | ProgramNode
  | SwitchStatementNode
  | WhileStatementNode;

type FunctionNode =
  | ArrowFunctionExpressionNode
  | ClassMethodNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | ObjectMethodNode;

type BlockParentNode =
  | ArrowFunctionExpressionNode
  | BlockStatementNode
  | ClassMethodNode
  | DoWhileStatementNode
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | ObjectMethodNode
  | ProgramNode
  | SwitchStatementNode
  | WhileStatementNode;

type FunctionParentNode =
  | ArrowFunctionExpressionNode
  | ClassMethodNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | ObjectMethodNode
  | ProgramNode;

type PureishNode =
  | ArrowFunctionExpressionNode
  | BooleanLiteralNode
  | ClassDeclarationNode
  | ClassExpressionNode
  | FunctionDeclarationNode
  | FunctionExpressionNode
  | NullLiteralNode
  | NumericLiteralNode
  | StringLiteralNode;

type TerminatorlessNode =
  | AwaitExpressionNode
  | BreakStatementNode
  | ContinueStatementNode
  | ReturnStatementNode
  | ThrowStatementNode
  | YieldExpressionNode;

type BinaryNode = BinaryExpressionNode | LogicalExpressionNode;

type BlockNode = BlockStatementNode | ProgramNode;

type StatementNode =
  | BlockStatementNode
  | BreakStatementNode
  | ClassDeclarationNode
  | ContinueStatementNode
  | DebuggerStatementNode
  | DeclareClassNode
  | DeclareFunctionNode
  | DeclareInterfaceNode
  | DeclareModuleNode
  | DeclareModuleExportsNode
  | DeclareTypeAliasNode
  | DeclareVariableNode
  | DoWhileStatementNode
  | EmptyStatementNode
  | ExportAllDeclarationNode
  | ExportDefaultDeclarationNode
  | ExportNamedDeclarationNode
  | ExpressionStatementNode
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode
  | FunctionDeclarationNode
  | IfStatementNode
  | ImportDeclarationNode
  | InterfaceDeclarationNode
  | LabeledStatementNode
  | ReturnStatementNode
  | SwitchStatementNode
  | ThrowStatementNode
  | TryStatementNode
  | TypeAliasNode
  | VariableDeclarationNode
  | WhileStatementNode
  | WithStatementNode;

type LiteralNode =
  | BooleanLiteralNode
  | NullLiteralNode
  | NumericLiteralNode
  | RegExpLiteralNode
  | StringLiteralNode
  | TemplateLiteralNode;

type ImmutableNode =
  | BooleanLiteralNode
  | JSXAttributeNode
  | JSXClosingElementNode
  | JSXElementNode
  | JSXExpressionContainerNode
  | JSXOpeningElementNode
  | JSXSpreadChildNode
  | JSXTextNode
  | NullLiteralNode
  | NumericLiteralNode
  | StringLiteralNode;

type CompletionStatementNode =
  | BreakStatementNode
  | ContinueStatementNode
  | ReturnStatementNode
  | ThrowStatementNode;

type ClassNode = ClassDeclarationNode | ClassExpressionNode;

type DeclarationNode =
  | ClassDeclarationNode
  | DeclareClassNode
  | DeclareFunctionNode
  | DeclareInterfaceNode
  | DeclareModuleNode
  | DeclareModuleExportsNode
  | DeclareTypeAliasNode
  | DeclareVariableNode
  | ExportAllDeclarationNode
  | ExportDefaultDeclarationNode
  | ExportNamedDeclarationNode
  | FunctionDeclarationNode
  | ImportDeclarationNode
  | InterfaceDeclarationNode
  | TypeAliasNode
  | VariableDeclarationNode;

type MethodNode = ClassMethodNode | ObjectMethodNode;

type PropertyNode = ClassPropertyNode | ObjectPropertyNode;

type ConditionalNode = ConditionalExpressionNode | IfStatementNode;

type FlowDeclarationNode =
  | DeclareClassNode
  | DeclareFunctionNode
  | DeclareInterfaceNode
  | DeclareModuleNode
  | DeclareModuleExportsNode
  | DeclareTypeAliasNode
  | DeclareVariableNode
  | InterfaceDeclarationNode
  | TypeAliasNode;

type LoopNode =
  | DoWhileStatementNode
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode
  | WhileStatementNode;

type WhileNode = DoWhileStatementNode | WhileStatementNode;

type ModuleDeclarationNode =
  | ExportAllDeclarationNode
  | ExportDefaultDeclarationNode
  | ExportNamedDeclarationNode
  | ImportDeclarationNode;

type ExportDeclarationNode =
  | ExportAllDeclarationNode
  | ExportDefaultDeclarationNode
  | ExportNamedDeclarationNode;

type ModuleSpecifierNode =
  | ExportDefaultSpecifierNode
  | ExportNamespaceSpecifierNode
  | ExportSpecifierNode
  | ImportDefaultSpecifierNode
  | ImportNamespaceSpecifierNode
  | ImportSpecifierNode;

type ExpressionWrapperNode =
  | ExpressionStatementNode
  | ParenthesizedExpressionNode
  | TypeCastExpressionNode;

type ForNode =
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode
  | ForStatementNode;

type ForXStatementNode =
  | ForAwaitStatementNode
  | ForInStatementNode
  | ForOfStatementNode;

type JSXNode =
  | JSXAttributeNode
  | JSXClosingElementNode
  | JSXElementNode
  | JSXEmptyExpressionNode
  | JSXExpressionContainerNode
  | JSXIdentifierNode
  | JSXMemberExpressionNode
  | JSXNamespacedNameNode
  | JSXOpeningElementNode
  | JSXSpreadAttributeNode
  | JSXSpreadChildNode
  | JSXTextNode;

type UserWhitespacableNode =
  | ObjectMethodNode
  | ObjectPropertyNode
  | ObjectTypeCallPropertyNode
  | ObjectTypeIndexerNode
  | ObjectTypePropertyNode
  | ObjectTypeSpreadPropertyNode;

type ObjectMemberNode = ObjectMethodNode | ObjectPropertyNode;

type UnaryLikeNode =
  | RestPropertyNode
  | SpreadElementNode
  | SpreadPropertyNode
  | UnaryExpressionNode;

type ArrayExpressionElementsNode = ExpressionNode | SpreadElementNode;

type ArrayPatternElementsNode = IdentifierNode | PatternNode | RestElementNode;

type ArrowFunctionExpressionBodyNode = BlockStatementNode | ExpressionNode;

type ClassBodyBodyNode = ClassMethodNode | ClassPropertyNode;

type ExportDefaultDeclarationDeclarationNode =
  | ClassDeclarationNode
  | ExpressionNode
  | FunctionDeclarationNode;

type ForAwaitStatementLeftNode = LValNode | VariableDeclarationNode;

type ForStatementInitNode = ExpressionNode | VariableDeclarationNode;

type ImportDeclarationSpecifiersNode =
  | ImportDefaultSpecifierNode
  | ImportNamespaceSpecifierNode
  | ImportSpecifierNode;

type JSXAttributeNameNode = JSXIdentifierNode | JSXNamespacedNameNode;

type JSXAttributeValueNode =
  | JSXElementNode
  | JSXExpressionContainerNode
  | StringLiteralNode;

type JSXClosingElementNameNode = JSXIdentifierNode | JSXMemberExpressionNode;

type JSXElementChildrenNode =
  | JSXElementNode
  | JSXExpressionContainerNode
  | JSXSpreadChildNode
  | JSXTextNode;

type JSXOpeningElementAttributesNode =
  | JSXAttributeNode
  | JSXSpreadAttributeNode;

type ObjectExpressionPropertiesNode =
  | ObjectMethodNode
  | ObjectPropertyNode
  | SpreadPropertyNode;

type ObjectPatternPropertiesNode = PropertyNode | RestPropertyNode;

type ObjectPropertyValueNode = ExpressionNode | PatternNode | RestElementNode;

type WhileStatementBodyNode = BlockStatementNode | StatementNode;

type JSXValueNode =
  | JSXTextNode
  | JSXExpressionContainerNode
  | JSXSpreadChildNode
  | JSXElementNode;
